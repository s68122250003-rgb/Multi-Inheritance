# Multi-Inheritance
CSD1102 Advance Computer Programming ปัณณธร คงสมหวัง 68122250003
1. Java สืบทอดหลาย Class พร้อมกันไม่ได้เพราะอะไร?
สาเหตุหลักที่ Java ไม่รองรับ Multiple Inheritance ในระดับ Class เป็นเพราะต้องการหลีกเลี่ยงปัญหาความกำกวมที่เรียกว่า Diamond Problem สมมติว่า Class C สืบทอดมาจาก Class A และ Class B ซึ่งทั้ง A และ B ดันมีเมธอดที่ชื่อเหมือนกัน (เช่น `start()`) เมื่อ Class C เรียกใช้ `start()` คอมไพเลอร์ของ Java จะไม่สามารถตัดสินใจได้เลยว่าควรจะดึงโค้ดของ A หรือ B มาทำงาน เพื่อตัดปัญหาความซับซ้อนนี้ Java จึงบังคับให้ `extends` ได้แค่คลาสเดียวเท่านั้น

2. เราใช้ Interface + Composition แทนอย่างไร
เพื่อก้าวข้ามข้อจำกัดการสืบทอดคลาสเดียว เราใช้วิธีการออกแบบระบบใหม่ดังนี้:
ใช้ Interface สำหรับ "พฤติกรรม" (Can-do):เราให้หุ่นยนต์ `implements` หลายๆ Interface (เช่น `Flyable`, `Drivable`) เพื่อรับความสามารถต่างๆ มา โดยไม่ต้องสนใจว่าข้างในจะเก็บข้อมูลอย่างไร (แยกส่วนพฤติกรรมออกจากการสืบทอดคลาส)
ใช้ Composition สำหรับ "ชิ้นส่วน/ข้อมูล" (Has-a): แทนที่จะให้หุ่นยนต์สืบทอดคุณสมบัติมาจากคลาสแบตเตอรี่ หรือ GPS เราใช้วิธีสร้างตัวแปร (Field) ของ `Battery`, `GPSTracker`, และ `ThermalCamera` ไว้ในตัวหุ่นยนต์แทน วิธีนี้เรียกว่า "การประกอบร่าง" (Composition) ซึ่งยืดหยุ่นกว่าการสืบทอด เพราะเราสามารถเปลี่ยนชนิดของชิ้นส่วนได้ง่ายในอนาคต

3. อธิบายการแก้ปัญหา Default Method ชื่อชนกัน
ในโปรเจกต์นี้ Interface `Flyable` และ `Drivable` มี default method ที่ชื่อว่า `status()` เหมือนกัน เมื่อคลาส `RescueRobot` นำทั้งคู่มา implement จะเกิด Error ทันทีเพราะคอมไพเลอร์สับสน
วิธีแก้ปัญหา: Java บังคับให้คลาส `RescueRobot` ต้องประกาศ @Override เมธอด `status()` ขึ้นมาใหม่เองเพื่อตัดสินใจว่าจะทำอย่างไรกับเมธอดที่ชนกัน ในโจทย์นี้เราได้แก้ปัญหาโดยการเรียกใช้ผลลัพธ์จากทั้งสอง Interface มาต่อกัน ด้วยไวยากรณ์พิเศษคือ `InterfaceName.super.methodName()` ดังนี้:
```java
@Override
public String status() {
    return "ROBOT: " + Flyable.super.status() + " + " + Drivable.super.status();
}
